<!DOCTYPE html>

<html lang="en">
<!--

		ICG Project 2024 - Night City
        Alexandre Ribeiro

-->

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title> Night City </title>

    <link rel="stylesheet" href="style.css">

    <!-- Local imports -->
    <script type="importmap">
        {
          "imports": {
            "three": "./imports/three.module.js",
            "three/addons/": "./imports/addons/"
          }
        }
    </script>

    <script type="module">

        import * as THREE from "three";

        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
        import { VOXLoader, VOXMesh } from 'three/addons/loaders/VOXLoader.js';

        // The day-night cycle comes from an extension available here: https://github.com/jeromeetienne/threex.daynight
        import { THREEx } from 'three/addons/other/DayNightCycle.js';

        // To store the scene graph, and elements useful to rendering the scene
        const sceneElements = {
            sceneGraph: null,
            camera: null,
            control: null,
            renderer: null,
        };

        const cameras = {
            perspective: null,
            orthographic: null,
            firstperson: null,
        };

        const controls = {
            per: null,
            ort: null,
            fps: null,
        };

        const stands = {
            cityTower: null,
            cityPlane: null,
        };

        const daynight = {
            sunSphere: null,
            sunLight: null,
            skydom: null,
            starField: null,
        };

        const wheels = [];

        var streetLightBoxes = [];
        var streetLights = [];
        
        // The positions correspond to the blender coordinates
        // z axis is simetrical in comparison to the blender coordinates (Threejs z = Blender -y)
        const scale = 3;
        const offset = 0.5;
        const streetLightPositions = [
            { x: 0, y: 2, z: 1.05, rotation: 3*Math.PI/2 }, // Pointing downwards
            { x: 0, y: 2, z: -1.05, rotation: Math.PI/2 }, // Pointing upwards
            { x: 1.05, y: 2, z: 0, rotation: Math.PI }, // Pointing to the right
            { x: -1.05, y: 2, z: 0, rotation: 0 }, // Pointing to the left
            // Down
            { x: -3, y: 2, z: -4.95, rotation: 3*Math.PI/2 },
            { x: -1, y: 2, z: -4.95, rotation: 3*Math.PI/2 },
            { x: 1, y: 2, z: -4.95, rotation: 3*Math.PI/2 },
            { x: 3, y: 2, z: -4.95, rotation: 3*Math.PI/2 },
            { x: 5, y: 2, z: -4.95, rotation: 3*Math.PI/2 },
            { x: 7, y: 2, z: -4.95, rotation: 3*Math.PI/2 },
            { x: -7, y: 2, z: -1.95, rotation: 3*Math.PI/2 },
            // Up
            { x: 3, y: 2, z: 4.95, rotation: Math.PI/2 },
            { x: 1, y: 2, z: 4.95, rotation: Math.PI/2 },
            { x: -1, y: 2, z: 4.95, rotation: Math.PI/2 },
            { x: -3, y: 2, z: 4.95, rotation: Math.PI/2 },
            { x: -6, y: 2, z: 4.95, rotation: Math.PI/2 },
            { x: -8, y: 2, z: 4.95, rotation: Math.PI/2 },
            { x: -3, y: 2, z: 7.95, rotation: Math.PI/2 },
            { x: -1, y: 2, z: 7.95, rotation: Math.PI/2 },
            { x: 1, y: 2, z: 7.95, rotation: Math.PI/2 },
            { x: 3, y: 2, z: 7.95, rotation: Math.PI/2 },
            { x: -3, y: 2, z: -1.05, rotation: Math.PI/2 },
            { x: 7, y: 2, z: -1.05, rotation: Math.PI/2 },
            // Right
            { x: -8.95, y: 2, z: 0, rotation: Math.PI },
            { x: -8.95, y: 2, z: 3, rotation: Math.PI },
            { x: -4.95, y: 2, z: -9, rotation: Math.PI },
            { x: -4.95, y: 2, z: -6, rotation: Math.PI },
            { x: -4.95, y: 2, z: -3, rotation: Math.PI },
            { x: -4.95, y: 2, z: 0, rotation: Math.PI },
            { x: -4.95, y: 2, z: 3, rotation: Math.PI },
            { x: -4.95, y: 2, z: 6, rotation: Math.PI },
            { x: -4.95, y: 2, z: 9, rotation: Math.PI },
            { x: 1.05, y: 2, z: -3, rotation: Math.PI },
            { x: 1.05, y: 2, z: 3, rotation: Math.PI },
            // Left
            { x: -4.05, y: 2, z: 1.5, rotation: 0 },
            { x: 4.95, y: 2, z: 0, rotation: 0 },
            { x: 4.95, y: 2, z: 2, rotation: 0 },
            { x: 4.95, y: 2, z: 4, rotation: 0 },
            { x: 4.95, y: 2, z: 6, rotation: 0 },
            { x: 8.95, y: 2, z: -3, rotation: 0 },
        ]

        for (var i in streetLightPositions) {
            streetLightPositions[i].x *= scale;
            streetLightPositions[i].z *= scale;

            if (streetLightPositions[i].rotation == 0) {
                streetLightPositions[i].x -= offset;
            } else if (streetLightPositions[i].rotation == Math.PI) {
                streetLightPositions[i].x += offset;
            } else if (streetLightPositions[i].rotation == Math.PI/2) {
                streetLightPositions[i].z -= offset;
            } else if (streetLightPositions[i].rotation == 3*Math.PI/2) {
                streetLightPositions[i].z += offset;
            }
        }

        // Models

        const models = [
            {
                name: "Map",
                path: "models/untitled.obj",
                mtl: "models/untitled.mtl",
            },
            {
                name: "Sedan",
                path: "models/Cars/sedan.obj",
                mtl: "models/Cars/sedan.mtl",
            },
        ]

        // Useful constants

        const ortScale = 80 // Orthographic camera constant, to define the viewing box

        // HELPER FUNCTIONS

        function createLight(params) {
            const lightGeometry = new THREE.BoxGeometry( 0.13, 0.05, 0.12 );
            const lightMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );
            const lightBox = new THREE.Mesh( lightGeometry, lightMaterial );

            lightBox.receiveShadow = true;
            lightBox.castShadow = true;
            lightBox.material.emissive.set( 0xffffff );
            lightBox.material.emissiveIntensity = 0.25;

            lightBox.position.set( params.x, params.y, params.z );
            lightBox.rotation.y = params.rotation;

            // Place a spotlight at the origin, pointing down the y-axis
            const spotLight = new THREE.SpotLight( 0xffffff, 1 );
            spotLight.position.set( params.x, params.y, params.z );
            spotLight.target.position.set( params.x, -1, params.z );
            spotLight.target.updateMatrixWorld();
            spotLight.visible = false;
            
            streetLights.push(spotLight);
            streetLightBoxes.push(lightBox);

            sceneElements.sceneGraph.add( lightBox );
            sceneElements.sceneGraph.add( spotLight );
            sceneElements.sceneGraph.add( spotLight.target );
        }

        const helper = {

            initEmptyScene: function (sceneElements) {

                // ************************** //
                // Create the 3D scene
                // ************************** //
                sceneElements.sceneGraph = new THREE.Scene();
                //sceneElements.sceneGraph.fog = new THREE.Fog( 0xffffff, 0, 750 );


                // ************************** //
                // Create the perspective camera and set it as the default camera
                // ************************** //
                const width = window.innerWidth;
                const height = window.innerHeight;
                const aspectRatio = width / height;
                const perCamera = new THREE.PerspectiveCamera( 45, aspectRatio, 0.1, 2000 );
                cameras.perspective = perCamera;
                perCamera.position.set( 30, 18, 30 );
                perCamera.lookAt( 0, 5, 0 );

                // ************************** //
                // Create the orthographic camera
                // ************************** //
                const ortCamera = new THREE.OrthographicCamera( width / -ortScale, width / ortScale, height / ortScale, height / -ortScale, 0.5, 1000 );
                cameras.orthographic = ortCamera;
                ortCamera.position.set( 30, 18, 30 );
                ortCamera.lookAt( 0, 5, 0 );


                // ************************** //
                // Create the first person camera
                // ************************** //
                const fpsCamera = new THREE.PerspectiveCamera( 75, aspectRatio, 0.1, 1000 );
                fpsCamera.position.set( 2, 10, 0 );
                cameras.firstperson = fpsCamera;


                // Set the default camera
                sceneElements.camera = perCamera;
                

                // -------------------------- //
                // Illumination
                // -------------------------- //

                // ************************** //
                // Add ambient light
                // ************************** //
                const ambientLight = new THREE.AmbientLight( 'rgb(214, 220, 227)', 0.05 );
                sceneElements.sceneGraph.add( ambientLight );


                // ************************** //
                // Add directional light (with shadows), to simulate the moon light
                // ************************** //

                //const moonlight = new THREE.DirectionalLight('rgb(255, 255, 255)', 0.3);
                //moonlight.position.set( 100, 100, 0 );
                //moonlight.castShadow = true;

                //Set up shadow properties for the light

                //const b = 20;

                //moonlight.shadow.camera.left = - b;
                //moonlight.shadow.camera.right = b;
                //moonlight.shadow.camera.top = b;
                //moonlight.shadow.camera.bottom = - b;

                //moonlight.shadow.mapSize.width = 2048;
                //moonlight.shadow.mapSize.height = 2048;
                //moonlight.shadow.camera.near = 130; // default
                //moonlight.shadow.camera.far = 150; // default

                //sceneElements.sceneGraph.add(moonlight);
                //sceneElements.sceneGraph.add( new THREE.CameraHelper( moonlight.shadow.camera ) );

                // ***************************** //
                // Day-night cycle
                // ***************************** //

                daynight.sunSphere	= new THREEx.DayNight.SunSphere()
                sceneElements.sceneGraph.add( daynight.sunSphere.object3d )

                daynight.sunLight	= new THREEx.DayNight.SunLight()
                sceneElements.sceneGraph.add( daynight.sunLight.object3d )
                
                daynight.skydom	= new THREEx.DayNight.Skydom()
                sceneElements.sceneGraph.add( daynight.skydom.object3d )

                //daynight.starField	= new THREEx.DayNight.StarField()
                //sceneElements.sceneGraph.add( daynight.starField.object3d )

                // ***************************** //
                // Add point light souce (with shadows)
                // ***************************** //
                const light_1 = new THREE.PointLight( 'rgb(255, 255, 255)', 19 );
                light_1.decay = 1;
                light_1.position.set( 10, 10, 2 );
                //sceneElements.sceneGraph.add( light_1 );

                // Setup shadow properties for the point light
                light_1.castShadow = true;
                light_1.shadow.mapSize.width = 2048;
                light_1.shadow.mapSize.height = 2048;

                // Give a name to the light
                light_1.name = "light 1";


                // *********************************** //
                // Add skybox
                // *********************************** //
                //const loader = new THREE.CubeTextureLoader();
                //loader.setPath( 'models/Skybox/' );
//
                //const textureCube = loader.load([
                //'px.png', 'nx.png',
                //'ny.png', 'py.png',
                //'nz.png', 'pz.png'
                //]);
//
                //sceneElements.sceneGraph.background = textureCube;

                // Apply this material to your objects
                const geometry = new THREE.BoxGeometry(1500, 10, 1500);
                const mesh = new THREE.MeshStandardMaterial({ color: 0xCCCCCC });
                const foggedObject = new THREE.Mesh(geometry, mesh);
                foggedObject.position.set(0, -400, 0);
                sceneElements.sceneGraph.add(foggedObject);

                // Create street lights
                for (var i in streetLightPositions) {
                    createLight(streetLightPositions[i]);
                }

                // -------------------------- //
                // Renderer
                // -------------------------- //
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                sceneElements.renderer = renderer;
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( width, height );

                // Setup shadowMap property
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap; //THREE.BasicShadowMap | THREE.PCFShadowMap |  THREE.VSMShadowMap | THREE.PCFSoftShadowMap

                renderer.shadowMap.soft = true;
                renderer.shadowMap.bias = -0.0001;
                renderer.shadowMap.darkness = 1;
                renderer.shadowMap.width = 2048;
                renderer.shadowMap.height = 2048;


                // **************************************** //
                // Add the rendered image in the HTML DOM
                // **************************************** //
                const htmlElement = document.querySelector( "#Tag3DScene" );
                htmlElement.appendChild( renderer.domElement );


                // -------------------------- //
                // Camera controls
                // -------------------------- //

                // Perpective camera
                controls.per = new OrbitControls( perCamera, renderer.domElement );
                controls.per.screenSpacePanning = true;
                controls.per.target.set(0, 5, 0);
                controls.per.maxDistance = 100;
                controls.per.saveState();
                
                controls.per.update();

                sceneElements.control = controls.per;

                // Orthographic camera
                controls.ort = new OrbitControls( ortCamera, renderer.domElement );
                controls.ort.screenSpacePanning = true;
                controls.ort.target.set( 0, 5, 0 );
                controls.ort.maxDistance = 100;
                controls.ort.saveState();

                controls.ort.update();

                // First Person camera
                
                controls.fps = new PointerLockControls( fpsCamera, renderer.domElement );
                controls.fps.disconnect();
                //controls.per.enabled = false; controls.ort.enabled = false;
                controls.fps.connect(); controls.fps.lock(); controls.fps.isLocked === true;
                sceneElements.sceneGraph.add( controls.fps.getObject() );
            },

            render: function ( sceneElements ) {
                sceneElements.renderer.render( sceneElements.sceneGraph, sceneElements.camera );
            },
        };

        // FUNCTIONS FOR BUILDING THE SCENE

        const scene = {

            // Create and insert in the scene graph the models of the 3D scene

            load3DObjects: function ( sceneGraph ) {

                // ************************** //
                // Create the city plane
                // ************************** //
                const loader = new THREE.TextureLoader();
                const grassTexture = loader.load('./images/grass/grass_texture.png');
                const displacementMap = loader.load('./images/grass/grass_displacement.png');
                const aoMap = loader.load('./images/grass/grass_ao.png');
                const roughnessMap = loader.load('./images/grass/grass_roughness.png');

                const factor = 8;

                grassTexture.wrapS = THREE.RepeatWrapping;
                grassTexture.wrapT = THREE.RepeatWrapping;
                grassTexture.repeat.set(factor, factor); // Adjust these values to scale the texture as needed

                displacementMap.wrapS = THREE.RepeatWrapping;
                displacementMap.wrapT = THREE.RepeatWrapping;
                displacementMap.repeat.set(factor, factor); // Adjust these values to match the grass texture

                aoMap.wrapS = THREE.RepeatWrapping;
                aoMap.wrapT = THREE.RepeatWrapping;
                aoMap.repeat.set(factor, factor); // Adjust these values to match the grass texture

                roughnessMap.wrapS = THREE.RepeatWrapping;
                roughnessMap.wrapT = THREE.RepeatWrapping;
                roughnessMap.repeat.set(factor, factor); // Adjust these values to match the grass texture

                const grassMaterial = new THREE.MeshStandardMaterial({
                    map: grassTexture,
                    displacementMap: displacementMap,
                    displacementScale: 0,
                    aoMap: aoMap,
                    aoMapIntensity: 0.5,
                    roughnessMap: roughnessMap,
                    roughness: 0.5,
                });

                const otherMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Brown color for the other sides

                // Step 4: Create an array of materials, assigning the grass material to the upper face (index 4)
                const materials = [
                otherMaterial, // Right face
                otherMaterial, // Left face
                grassMaterial, // Front face (this is actually the upper face)
                otherMaterial, // Bottom face
                otherMaterial,
                otherMaterial, // Back face
                ];


                const planeGeometry = new THREE.BoxGeometry( 60, 1000, 60 );
                const planeMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(255,255,255)' });
                const cityPlane = new THREE.Mesh( planeGeometry, materials );
                cityPlane.position.set( 0, -500, 0 );
                cityPlane.receiveShadow = true;
                cityPlane.name = "cityPlane";
                stands.cityPlane = cityPlane;

                sceneGraph.add( cityPlane );

                // ************************** //
                // Setting up a loading manager
                // ************************** //
                const manager = new THREE.LoadingManager();
                manager.onStart = function ( url, itemsLoaded, itemsTotal ) {
                    console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
                };

                manager.onLoad = function ( ) {
                    console.log( 'Loading complete!');
                };

                manager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
                    console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
                };

                manager.onError = function ( url ) {
                    console.log( 'There was an error loading ' + url );
                };

                // ************************** //
                // Load a OBJ model
                // ************************** //
                const mtlLoader = new MTLLoader( manager );

                const loadingPromises = [];

                // For every OBJ model in the directory, load the corresponding MTL file
                models.forEach(model => {
                    const promise = new Promise((resolve, reject) => {
                        mtlLoader.load(
                            model.mtl,
                            (materials) => {
                                materials.preload()
                                const objLoader = new OBJLoader()
                                objLoader.setMaterials( materials )
                                objLoader.load(
                                    model.path,
                                    (object) => {
                                        console.log(object)
                                        object.traverse((child) => {
                                            if (child instanceof THREE.Mesh) {
                                                child.castShadow = true;
                                                child.receiveShadow = true;
                                            }
                                        });
                                        object.receiveShadow = true;
                                        object.castShadow = true;
                                        object.name = model.name;
                                        if (model.name == "Map") {
                                            object.scale.set( 3, 3, 3 );
                                            object.position.set( 0, 0.05, 0 );
                                            sceneGraph.add( object );
                                        }
                                        else if (model.name == "Sedan") {
                                            var textureLoader = new THREE.TextureLoader();
                                            var texture = textureLoader.load( 'models/Cars/colormap.png' );
                                            object.traverse( function ( child ) {
                                                if ( child instanceof THREE.Mesh ) {
                                                    child.material.map = texture;
                                                }
                                            });
                                            object.scale.set( 0.5, 0.5, 0.5 );
                                            object.position.set( -14, 0.05, -29 );
                                            sceneGraph.add( object );
                                        }
                                        
                                        resolve();

                                        // Setup model
                                        scene.setup( object )
                                    },
                                    (xhr) => {
                                        console.log( model.name + ' - ' + ( xhr.loaded / xhr.total ) * 43333333330 + '% loaded' )
                                    },
                                    (error) => {
                                        console.log( model.name + ' - ' + 'An error happened' ); 
                                        reject(error);
                                    }
                                )
                            },
                            (xhr) => {
                                console.log( ( model.name + ' - ' + xhr.loaded / xhr.total ) * 100 + '% loaded' )
                            },
                            (error) => {
                                console.log( model.name + ' - ' + 'An error happened' )
                            }
                        )
                    });
                    loadingPromises.push(promise);
                });

                return Promise.all(loadingPromises);
            },

            setup: function ( obj ) {

                console.log( obj.name );
                
                // ************************** //
                // Setup models
                // ************************** //


            }
        };

        // ANIMATION
        

        // Animation functions

        let raycaster;

        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let sprint = false;
        let canDoubleJump = false;
        let canJump = false;

        const normalSpeed = 40.0;
        const sprintSpeed = 70.0;
        const slowdownSpeed = 10.0;

        const gravity = 9.8;

        let prevTime = performance.now();

        const charHeight = 0.6;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const vertex = new THREE.Vector3();
        const color = new THREE.Color();

        raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, charHeight );
        // Raycaster helper

        // begining position
        var sunAngle = 1/6*Math.PI*2;
        var lightsOn = false;
        var windowLightIntensity = 0;
        // the day duraction in seconds
        var dayDuration	= 30

        function computeFrame() {
            //sceneElements.sceneGraph.add( new THREE.ArrowHelper( raycaster.ray.direction, raycaster.ray.origin, 2, 0xff0000 ) );
            // FPS Controls adapted from https://threejs.org/examples/misc_controls_pointerlock.html

            const time = performance.now();
            const delta = ( time - prevTime ) / 1000;

            var phase	= THREEx.DayNight.currentPhase(sunAngle)

            // Street lights
            if (phase === 'twilight' && lightsOn == false) {
                // Turning lights on
                for (var i in streetLights) {
                    streetLights[i].visible = true;
                }
                for (var i in streetLightBoxes) {
                    streetLightBoxes[i].material.emissiveIntensity = 1;
                }
                for (var i in sceneElements.sceneGraph.getObjectByName('Map').children) {
                    var obj = sceneElements.sceneGraph.getObjectByName('Map').children[i];

                    if (obj.name.startsWith('low') || obj.name.startsWith('small') || obj.name.startsWith('large') || obj.name.startsWith('skyscraper')) {
                        for (var i in obj.material) {
                            if (obj.material[i].name.startsWith('window')) {
                                obj.material[i].emissive.set(0xffffff);
                                windowLightIntensity += 0.0001;
                                obj.material[i].emissiveIntensity = windowLightIntensity;
                            }
                        }
                    }
                }
                if (windowLightIntensity > 0.5) {
                    lightsOn = true;
                }
            } else if (phase === 'day' && lightsOn == true) {
                // Turning lights off
                for (var i in streetLights) {
                    streetLights[i].visible = false;
                }
                for (var i in streetLightBoxes) {
                    streetLightBoxes[i].material.emissiveIntensity = 0.25;
                }

                for (var i in sceneElements.sceneGraph.getObjectByName('Map').children) {
                    var obj = sceneElements.sceneGraph.getObjectByName('Map').children[i];

                    if (obj.name.startsWith('low') || obj.name.startsWith('small') || obj.name.startsWith('large') || obj.name.startsWith('skyscraper')) {
                        for (var i in obj.material) {
                            if (obj.material[i].name.startsWith('window')) {
                                if (windowLightIntensity - 0.0001 < 0) {
                                    windowLightIntensity = 0;
                                } else {
                                    windowLightIntensity -= 0.0001;
                                }
                                obj.material[i].emissiveIntensity = windowLightIntensity;
                            }
                        }
                    }
                }
                if (windowLightIntensity == 0) {
                    lightsOn = false;
                }
            }

            // Car Animation
            var car = sceneElements.sceneGraph.getObjectByName('Sedan');
            const carVelocity = 7;
            car.position.z += carVelocity * delta;

            if (car.position.z > 29) {
                car.position.z = -30;
            }

            // Wheel rotation
            //for (var i in wheels) {
            //    console.log(wheels);
            //    console.log(wheels[i]);
            //    wheels[i].children[0].rotation.x += carVelocity * delta;
            //}
            
            // FP Controls
            if ( controls.fps.isLocked === true && sceneElements.camera == cameras.firstperson ) {
                raycaster.ray.origin.copy( controls.fps.getObject().position );
                
                const intersects = [];
                var temp;
                for (var i in sceneElements.sceneGraph.children) {
                    if (sceneElements.sceneGraph.children[i] instanceof THREE.Group) {
                        temp = raycaster.intersectObjects(sceneElements.sceneGraph.children[i].children, true);
                        if (temp.length > 0) {
                            intersects.push(...temp);
                        }
                    } else if (sceneElements.sceneGraph.children[i] instanceof THREE.Mesh) {
                        temp = raycaster.intersectObject(sceneElements.sceneGraph.children[i]);
                        if (temp.length > 0) {
                            intersects.push(temp);
                        }
                    }
                }


                if ( intersects.length > 0 ) {

                    const distance = intersects[0].distance;

                    for ( let i = 1; i < intersects.length; i ++ ) {
                        if ( intersects[i].distance < distance ) {
                            distance = intersects[i].distance;
                        }
                    }

                    if ( distance > 3*charHeight/4 && distance < charHeight ) {
                        controls.fps.getObject().position.y += (charHeight - distance);
                    }
                }

                const onObject = intersects.length > 0;

                velocity.x -= velocity.x * slowdownSpeed * delta;
                velocity.z -= velocity.z * slowdownSpeed * delta;

                velocity.y -= gravity * 3.0 * delta; // 100.0 = mass

                direction.z = Number( moveForward ) - Number( moveBackward );
                direction.x = Number( moveRight ) - Number( moveLeft );
                direction.normalize(); // this ensures consistent movements in all directions

                if ( moveForward || moveBackward ) velocity.z -= direction.z * (sprint ? sprintSpeed : normalSpeed) * delta;
                if ( moveLeft || moveRight ) velocity.x -= direction.x * (sprint ? sprintSpeed : normalSpeed) * delta;

                if ( onObject === true ) {

                    velocity.y = Math.max( 0, velocity.y );
                    canJump = true;

                }

                controls.fps.moveRight( - velocity.x * delta );
                controls.fps.moveForward( - velocity.z * delta );

                controls.fps.getObject().position.y += ( velocity.y * delta ); // new behavior

                if ( controls.fps.getObject().position.y < 0 ) {

                    velocity.y = 0;
                    controls.fps.getObject().position.y = 0;

                    canJump = true;

                }

            }

            sunAngle += delta/dayDuration * Math.PI*2;
            //daynight.starField.update(sunAngle);
            daynight.skydom.update(sunAngle);
            daynight.sunLight.update(sunAngle);
            daynight.sunSphere.update(sunAngle);

            // Model animations

            //crosswalkLights(time);

            prevTime = time;

            // Rendering
            helper.render( sceneElements );

            // Animation
            // Call for the next frame
            requestAnimationFrame( computeFrame );
        }

        function init() {
            helper.initEmptyScene( sceneElements );
            scene.load3DObjects( sceneElements.sceneGraph ).then(() => {
                requestAnimationFrame( computeFrame );
            });
        }

        // HANDLING EVENTS

        // Event Listeners

        // Update render image size and camera aspect when the window is resized
        function resizeWindow( eventParam ) {
            const width = window.innerWidth;
            const height = window.innerHeight;

            // Perspective camera
            if (sceneElements.camera.isPerspectiveCamera) {
                sceneElements.camera.aspect = width / height;
                sceneElements.camera.updateProjectionMatrix();            
            }
            else {
                cameras.orthographic.left = width / -ortScale;
                cameras.orthographic.right = width / ortScale;
                cameras.orthographic.top = height / ortScale;
                cameras.orthographic.bottom = height / -ortScale;
            }

            sceneElements.renderer.setSize( width, height );

            helper.render( sceneElements );

            // Comment when doing animation
            // computeFrame(sceneElements);
        }

        const onKeyDown = function ( event ) {

            switch ( event.code ) {

                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;

                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;

                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;

                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;

                case 'ShiftLeft':
                    sprint = true;
                    break;

                case 'Space':
                    if ( canJump === true ) {
                        velocity.y = 10;
                        canDoubleJump = true;
                    }
                    else if ( canDoubleJump === true ) {
                        velocity.y = 10;
                        canDoubleJump = false;
                    }
                    canJump = false;
                    break;

                case 'KeyR':
                    controls.per.reset();
                    controls.ort.reset();
                    controls.fps.reset();
                    break;
                
                case 'KeyP':
                    if (sceneElements.camera == cameras.perspective) {
                        console.log( "Orthographic Camera" );

                        sceneElements.camera = cameras.orthographic;
                    }
                    else if (sceneElements.camera == cameras.orthographic) {
                        console.log( "First Person Camera" );

                        sceneElements.camera = cameras.firstperson;
                        controls.fps.connect(); controls.fps.lock();
                        controls.per.enabled = false; controls.ort.enabled = false;
                    }
                    else {
                        console.log( "Perspective Camera" );

                        controls.fps.disconnect(); controls.fps.unlock(); controls.fps.isLocked = false;
                        controls.per.enabled = true; controls.ort.enabled = true;
                        sceneElements.camera = cameras.perspective;
                    }

                    controls.ort.update();
                    controls.per.update();

                    break;

            }

        };

        const onKeyUp = function ( event ) {

            switch ( event.code ) {

                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;

                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;

                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;

                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;

                case 'ShiftLeft':
                    sprint = false;
                    break;

            }

        };

        window.addEventListener( 'resize', resizeWindow );
        document.addEventListener( 'keydown', onKeyDown );
        document.addEventListener( 'keyup', onKeyUp );

        // STARTING
        init();

    </script>

</head>

<body>
    <div id="Tag3DScene"> </div>
</body>

</html>