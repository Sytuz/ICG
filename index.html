<!DOCTYPE html>

<html lang="en">
<!--

		ICG Project 2024 - Night City
        Alexandre Ribeiro

-->

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title> Night City </title>

    <link rel="stylesheet" href="style.css">

    <!-- Local imports -->
    <script type="importmap">
        {
          "imports": {
            "three": "./imports/three.module.js",
            "three/addons/": "./imports/addons/"
          }
        }
    </script>

    <script type="module">

        import * as THREE from "three";

        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
        import { VOXLoader, VOXMesh } from 'three/addons/loaders/VOXLoader.js';

        // The day-night cycle comes from an extension available here: https://github.com/jeromeetienne/threex.daynight
        import { THREEx } from 'three/addons/other/DayNightCycle.js';

        // To store the scene graph, and elements useful to rendering the scene
        const sceneElements = {
            sceneGraph: null,
            camera: null,
            control: null,
            renderer: null,
        };

        const cameras = {
            perspective: null,
            orthographic: null,
            firstperson: null,
        };

        const controls = {
            per: null,
            ort: null,
            fps: null,
        };

        const stands = {
            cityTower: null,
            cityPlane: null,
        };

        const daynight = {
            sunSphere: null,
            sunLight: null,
            skydom: null,
            starField: null,
        };

        // Models

        const models = [
            {
                name: "StaticCity",
                path: "models/NightCity/NightCity-0-StaticCity.obj",
                mtl: "models/NightCity/NightCity-0-StaticCity.mtl",
            },
            {
                name: "CrosswalkGreen",
                path: "models/NightCity/NightCity-1-CrosswalkGreen.obj",
                mtl: "models/NightCity/NightCity-1-CrosswalkGreen.mtl",
            },
            {
                name: "CrosswalkRed",
                path: "models/NightCity/NightCity-2-CrosswalkRed.obj",
                mtl: "models/NightCity/NightCity-2-CrosswalkRed.mtl",
            },
            {
                name: "ICGBuilding",
                path: "models/NightCity/NightCity-3-ICGBuilding.obj",
                mtl: "models/NightCity/NightCity-3-ICGBuilding.mtl",
            },
            {
                name: "ICGSign",
                path: "models/NightCity/NightCity-4-ICGSign.obj",
                mtl: "models/NightCity/NightCity-4-ICGSign.mtl",
            },
            {
                name: "ICGIntLights",
                path: "models/NightCity/NightCity-5-ICGIntLights.obj",
                mtl: "models/NightCity/NightCity-5-ICGIntLights.mtl",
            },
            {
                name: "Map",
                path: "models/Targets/untitled.obj",
                mtl: "models/Targets/untitled.mtl",
            },
        ]

        // Useful constants

        const ortScale = 80 // Orthographic camera constant, to define the viewing box

        // HELPER FUNCTIONS

        const helper = {

            initEmptyScene: function (sceneElements) {

                // ************************** //
                // Create the 3D scene
                // ************************** //
                sceneElements.sceneGraph = new THREE.Scene();
                //sceneElements.sceneGraph.fog = new THREE.Fog( 0xffffff, 0, 750 );


                // ************************** //
                // Create the perspective camera and set it as the default camera
                // ************************** //
                const width = window.innerWidth;
                const height = window.innerHeight;
                const aspectRatio = width / height;
                const perCamera = new THREE.PerspectiveCamera( 45, aspectRatio, 0.1, 500 );
                cameras.perspective = perCamera;
                perCamera.position.set( 15, 18, 15 );
                perCamera.lookAt( 0, 5, 0 );

                // ************************** //
                // Create the orthographic camera
                // ************************** //
                const ortCamera = new THREE.OrthographicCamera( width / -ortScale, width / ortScale, height / ortScale, height / -ortScale, 0.5, 1000 );
                cameras.orthographic = ortCamera;
                ortCamera.position.set( 15, 18, 15 );
                ortCamera.lookAt( 0, 5, 0 );


                // ************************** //
                // Create the first person camera
                // ************************** //
                const fpsCamera = new THREE.PerspectiveCamera( 75, aspectRatio, 0.1, 1000 );
                fpsCamera.position.set( 0, 10, 0 );
                cameras.firstperson = fpsCamera;

                sceneElements.camera = perCamera;
                

                // -------------------------- //
                // Illumination
                // -------------------------- //

                // ************************** //
                // Add ambient light
                // ************************** //
                const ambientLight = new THREE.AmbientLight( 'rgb(214, 220, 227)', 0.05 );
                sceneElements.sceneGraph.add( ambientLight );


                // ************************** //
                // Add directional light (with shadows), to simulate the moon light
                // ************************** //

                //const moonlight = new THREE.DirectionalLight('rgb(255, 255, 255)', 0.3);
                //moonlight.position.set( 100, 100, 0 );
                //moonlight.castShadow = true;

                //Set up shadow properties for the light

                //const b = 20;

                //moonlight.shadow.camera.left = - b;
                //moonlight.shadow.camera.right = b;
                //moonlight.shadow.camera.top = b;
                //moonlight.shadow.camera.bottom = - b;

                //moonlight.shadow.mapSize.width = 2048;
                //moonlight.shadow.mapSize.height = 2048;
                //moonlight.shadow.camera.near = 130; // default
                //moonlight.shadow.camera.far = 150; // default

                //sceneElements.sceneGraph.add(moonlight);
                //sceneElements.sceneGraph.add( new THREE.CameraHelper( moonlight.shadow.camera ) );

                // ***************************** //
                // Day-night cycle
                // ***************************** //

                daynight.sunSphere	= new THREEx.DayNight.SunSphere()
                sceneElements.sceneGraph.add( daynight.sunSphere.object3d )

                daynight.sunLight	= new THREEx.DayNight.SunLight()
                sceneElements.sceneGraph.add( daynight.sunLight.object3d )

                daynight.skydom	= new THREEx.DayNight.Skydom()
                sceneElements.sceneGraph.add( daynight.skydom.object3d )

                daynight.starField	= new THREEx.DayNight.StarField()
                sceneElements.sceneGraph.add( daynight.starField.object3d )

                // ***************************** //
                // Add point light souce (with shadows)
                // ***************************** //
                const light_1 = new THREE.PointLight( 'rgb(255, 255, 255)', 19 );
                light_1.decay = 1;
                light_1.position.set( 10, 10, 2 );
                //sceneElements.sceneGraph.add( light_1 );

                // Setup shadow properties for the point light
                light_1.castShadow = true;
                light_1.shadow.mapSize.width = 2048;
                light_1.shadow.mapSize.height = 2048;

                // Give a name to the light
                light_1.name = "light 1";


                // *********************************** //
                // Add skybox
                // *********************************** //
                const loader = new THREE.CubeTextureLoader();
                loader.setPath( 'models/Skybox/' );

                const textureCube = loader.load([
                'px.png', 'nx.png',
                'ny.png', 'py.png',
                'nz.png', 'pz.png'
                ]);

                sceneElements.sceneGraph.background = textureCube;


                // -------------------------- //
                // Renderer
                // -------------------------- //
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                sceneElements.renderer = renderer;
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( width, height );

                // Setup shadowMap property
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;


                // **************************************** //
                // Add the rendered image in the HTML DOM
                // **************************************** //
                const htmlElement = document.querySelector( "#Tag3DScene" );
                htmlElement.appendChild( renderer.domElement );


                // -------------------------- //
                // Camera controls
                // -------------------------- //

                // Perpective camera
                controls.per = new OrbitControls( perCamera, renderer.domElement );
                controls.per.screenSpacePanning = true;
                controls.per.target.set(0, 5, 0);
                controls.per.maxDistance = 100;
                controls.per.saveState();
                
                controls.per.update();

                sceneElements.control = controls.per;

                // Orthographic camera
                controls.ort = new OrbitControls( ortCamera, renderer.domElement );
                controls.ort.screenSpacePanning = true;
                controls.ort.target.set( 0, 5, 0 );
                controls.ort.maxDistance = 100;
                controls.ort.saveState();

                controls.ort.update();

                // First Person camera
                
                controls.fps = new PointerLockControls( fpsCamera, renderer.domElement );
                //controls.fps.disconnect();
                controls.per.enabled = false; controls.ort.enabled = false;
                controls.fps.connect(); controls.fps.lock(); controls.fps.isLocked === true;
                sceneElements.sceneGraph.add( controls.fps.getObject() );
                console.log(controls.fps.getObject());

            },

            render: function ( sceneElements ) {
                sceneElements.renderer.render( sceneElements.sceneGraph, sceneElements.camera );
            },
        };

        // FUNCTIONS FOR BUILDING THE SCENE

        const scene = {

            // Create and insert in the scene graph the models of the 3D scene

            load3DObjects: function ( sceneGraph ) {

                // ************************** //
                // Create the city stand (long box)
                // ************************** //
                const towerGeometry = new THREE.BoxGeometry( 20, 1000, 20 );
                const towerMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(17,17,17)' });
                const cityTower = new THREE.Mesh( towerGeometry, towerMaterial );
                cityTower.position.set( 0, -500, 0 );
                cityTower.name = "cityTower";
                stands.cityTower = cityTower;

                sceneGraph.add( cityTower );

                // ************************** //
                // Create the orthogonal city stand (long plane)
                // ************************** //
                const planeGeometry = new THREE.BoxGeometry( 100, 1, 100 );
                const planeMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(255,255,255)' });
                const cityPlane = new THREE.Mesh( planeGeometry, planeMaterial );
                cityPlane.position.set( 0, -0.5, 0 );
                cityPlane.receiveShadow = true;
                cityPlane.name = "cityPlane";
                stands.cityPlane = cityPlane;

                // ************************** //
                // Setting up a loading manager
                // ************************** //
                const manager = new THREE.LoadingManager();
                manager.onStart = function ( url, itemsLoaded, itemsTotal ) {
                    console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
                };

                manager.onLoad = function ( ) {
                    console.log( 'Loading complete!');
                };

                manager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
                    console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
                };

                manager.onError = function ( url ) {
                    console.log( 'There was an error loading ' + url );
                };

                // ************************** //
                // Load a OBJ model
                // ************************** //
                const mtlLoader = new MTLLoader( manager );

                const loadingPromises = [];

                // For every OBJ model in the directory, load the corresponding MTL file
                models.forEach(model => {
                    const promise = new Promise((resolve, reject) => {
                        mtlLoader.load(
                            model.mtl,
                            (materials) => {
                                materials.preload()
                                const objLoader = new OBJLoader()
                                objLoader.setMaterials( materials )
                                objLoader.load(
                                    model.path,
                                    (object) => {
                                        object.traverse((child) => {
                                            if (child instanceof THREE.Mesh) {
                                                child.castShadow = true;
                                                child.receiveShadow = true;
                                            }
                                        });
                                        object.receiveShadow = true;
                                        object.castShadow = true;
                                        object.name = model.name;
                                        if (model.name == "Map") {
                                            object.scale.set( 3, 3, 3 );
                                            object.position.set( 0, 1, 0 );
                                            sceneGraph.add( object );
                                        }
                                        
                                        resolve();

                                        // Setup model
                                        scene.setup( object )
                                    },
                                    (xhr) => {
                                        console.log( model.name + ' - ' + ( xhr.loaded / xhr.total ) * 43333333330 + '% loaded' )
                                    },
                                    (error) => {
                                        console.log( model.name + ' - ' + 'An error happened' );
                                        reject(error);
                                    }
                                )
                            },
                            (xhr) => {
                                console.log( ( model.name + ' - ' + xhr.loaded / xhr.total ) * 100 + '% loaded' )
                            },
                            (error) => {
                                console.log( model.name + ' - ' + 'An error happened' )
                            }
                        )
                    });
                    loadingPromises.push(promise);
                });

                return Promise.all(loadingPromises);
            },

            setup: function ( obj ) {

                console.log( obj.name );
                
                // ************************** //
                // Setup models
                // ************************** //

                switch (obj.name) {
                    case "CrosswalkGreen":
                        //obj.position.set( 0, 0.01, 0 );
                        obj.castShadow = false;
                        obj.receiveShadow = false;
                        // Set emissive color
                        obj.traverse( function ( child ) {
                            if ( child instanceof THREE.Mesh ) {
                                child.material.color.set( 'rgb(17,17,17)' );
                                child.material.emissive.set( 0x00ff00 );
                                child.material.emissiveIntensity = 0;
                            }
                        });
                        break;
                    case "CrosswalkRed":
                        //obj.position.set( 0, 0.01, 0 );
                        obj.castShadow = false;
                        obj.receiveShadow = false;
                        obj.traverse( function ( child ) {
                            if ( child instanceof THREE.Mesh ) {
                                child.material.color.set( 'rgb(17,17,17)' );
                                child.material.emissive.set( 0xff0000 );
                                child.material.emissiveIntensity = 0;
                            }
                        });
                        break;
                    case "ICGSign":
                        obj.traverse( function ( child ) {
                            if ( child instanceof THREE.Mesh ) {
                                child.material.emissive.set( 0xff0000 );
                            }
                        });
                        break;
                    case "ICGIntLights":
                        obj.traverse( function ( child ) {
                            if ( child instanceof THREE.Mesh ) {
                                child.material.emissive.set( child.material.color );
                                child.material.emissiveIntensity = 0.4;
                            }
                        });
                        break;
                    case "Target":
                        obj.traverse( function ( child ) {
                            if ( child instanceof THREE.Mesh ) {
                                child.material.emissive.set( 0xff0000 );
                            }
                        });
                        obj.position.set( 0, 10, 0 );
                        break;
                }
            }
        };

        // ANIMATION
        

        // Animation functions

        let raycaster;

        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;

        let prevTime = performance.now();

        const height = 0.5;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const vertex = new THREE.Vector3();
        const color = new THREE.Color();

        raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, height );
        // Raycaster helper

        // begining position
        var sunAngle = -1/6*Math.PI*2;
        // the day duraction in seconds
        var dayDuration	= 30

        function computeFrame() {
            //sceneElements.sceneGraph.add( new THREE.ArrowHelper( raycaster.ray.direction, raycaster.ray.origin, 2, 0xff0000 ) );
            // FPS Controls adapted from https://threejs.org/examples/misc_controls_pointerlock.html

            const time = performance.now();
            const delta = ( time - prevTime ) / 1000;
            
            if ( controls.fps.isLocked === true ) {
                raycaster.ray.origin.copy( controls.fps.getObject().position );
                
                const intersects = [];
                var temp;
                for (var i in sceneElements.sceneGraph.children) {
                    if (sceneElements.sceneGraph.children[i] instanceof THREE.Group) {
                        temp = raycaster.intersectObjects(sceneElements.sceneGraph.children[i].children, true);
                        if (temp.length > 0) {
                            intersects.push(...temp);
                        }
                    } else if (sceneElements.sceneGraph.children[i] instanceof THREE.Mesh) {
                        temp = raycaster.intersectObject(sceneElements.sceneGraph.children[i]);
                        if (temp.length > 0) {
                            intersects.push(temp);
                        }
                    }
                }


                if ( intersects.length > 0 ) {

                    const distance = intersects[0].distance;

                    for ( let i = 1; i < intersects.length; i ++ ) {
                        if ( intersects[i].distance < distance ) {
                            distance = intersects[i].distance;
                        }
                    }

                    if ( distance > 1 && distance < height ) {
                        controls.fps.getObject().position.y += (height - distance);
                    }
                }
                const onObject = intersects.length > 0;

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                velocity.y -= 9.8 * 5.0 * delta; // 100.0 = mass

                direction.z = Number( moveForward ) - Number( moveBackward );
                direction.x = Number( moveRight ) - Number( moveLeft );
                direction.normalize(); // this ensures consistent movements in all directions

                if ( moveForward || moveBackward ) velocity.z -= direction.z * 20.0 * delta;
                if ( moveLeft || moveRight ) velocity.x -= direction.x * 20.0 * delta;

                if ( onObject === true ) {

                    velocity.y = Math.max( 0, velocity.y );
                    canJump = true;

                }

                controls.fps.moveRight( - velocity.x * delta );
                controls.fps.moveForward( - velocity.z * delta );

                controls.fps.getObject().position.y += ( velocity.y * delta ); // new behavior

                if ( controls.fps.getObject().position.y < 1.1 ) {

                    velocity.y = 0;
                    controls.fps.getObject().position.y = 1.1;

                    canJump = true;

                }

                console.log(canJump);
            }

            sunAngle += delta/dayDuration * Math.PI*2;
            daynight.starField.update(sunAngle);
            daynight.skydom.update(sunAngle);
            daynight.sunLight.update(sunAngle);
            daynight.sunSphere.update(sunAngle);

            // Model animations

            //crosswalkLights(time);

            prevTime = time;

            // Rendering
            helper.render( sceneElements );

            // Animation
            // Call for the next frame
            requestAnimationFrame( computeFrame );
        }

        function init() {
            helper.initEmptyScene( sceneElements );
            scene.load3DObjects( sceneElements.sceneGraph ).then(() => {
                requestAnimationFrame( computeFrame );
            });
        }

        // HANDLING EVENTS

        // Event Listeners

        // Update render image size and camera aspect when the window is resized
        function resizeWindow( eventParam ) {
            const width = window.innerWidth;
            const height = window.innerHeight;

            // Perspective camera
            if (sceneElements.camera.isPerspectiveCamera) {
                sceneElements.camera.aspect = width / height;
                sceneElements.camera.updateProjectionMatrix();            
            }
            else {
                cameras.orthographic.left = width / -ortScale;
                cameras.orthographic.right = width / ortScale;
                cameras.orthographic.top = height / ortScale;
                cameras.orthographic.bottom = height / -ortScale;
            }

            sceneElements.renderer.setSize( width, height );

            helper.render( sceneElements );

            // Comment when doing animation
            // computeFrame(sceneElements);
        }

        const onKeyDown = function ( event ) {

            switch ( event.code ) {

                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;

                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;

                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;

                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;

                case 'Space':
                    if ( canJump === true ) velocity.y += 25;
                    canJump = false;
                    break;

                case 'KeyR':
                    controls.per.reset();
                    controls.ort.reset();
                    controls.fps.reset();
                    break;
                
                case 'KeyP':
                    if (sceneElements.camera == cameras.perspective) {
                        console.log( "Orthographic Camera" );

                        sceneElements.camera = cameras.orthographic;
                        sceneElements.sceneGraph.remove( stands.cityTower );
                        sceneElements.sceneGraph.add( stands.cityPlane );
                    }
                    else if (sceneElements.camera == cameras.orthographic) {
                        console.log( "First Person Camera" );

                        sceneElements.camera = cameras.firstperson;
                        sceneElements.sceneGraph.remove( stands.cityPlane );
                        sceneElements.sceneGraph.add( stands.cityTower );
                        controls.fps.connect(); controls.fps.lock();
                        controls.per.enabled = false; controls.ort.enabled = false;
                    }
                    else {
                        console.log( "Perspective Camera" );

                        controls.fps.disconnect(); controls.fps.unlock(); controls.fps.isLocked = false;
                        controls.per.enabled = true; controls.ort.enabled = true;
                        sceneElements.camera = cameras.perspective;
                    }

                    controls.ort.update();
                    controls.per.update();

                    break;

            }

        };

        const onKeyUp = function ( event ) {

            switch ( event.code ) {

                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;

                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;

                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;

                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;

            }

        };

        window.addEventListener( 'resize', resizeWindow );
        document.addEventListener( 'keydown', onKeyDown );
        document.addEventListener( 'keyup', onKeyUp );

        // STARTING
        init();

    </script>

</head>

<body>
    <div id="Tag3DScene"> </div>
</body>

</html>