<!DOCTYPE html>

<html lang="en">
<!--

		ICG Project 2024 - Night City
        Alexandre Ribeiro

-->

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title> Night City </title>

    <link rel="stylesheet" href="style.css">

    <!-- Local imports -->
    <script type="importmap">
        {
          "imports": {
            "three": "./imports/three.module.js",
            "three/addons/": "./imports/addons/"
          }
        }
    </script>

    <script type="module">

        import * as THREE from "three";

        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';

        /* -- The day-night cycle comes from an extension available here: https://github.com/jeromeetienne/threex.daynight -- */
        import { THREEx } from 'three/addons/other/DayNightCycle.js';

        /* -- Useful constants -- */
        const sceneElements = {
            sceneGraph: null,
            camera: null,
            control: null,
            renderer: null,
        };

        const cameras = {
            perspective: null,
            orthographic: null,
            firstperson: null,
        };

        const controls = {
            per: null,
            ort: null,
            fps: null,
        };

        const daynight = {
            sunSphere: null,
            sunLight: null,
            skydom: null,
            starField: null,
        };

        const ortScale = 80;

        /* -- Variables to store streetlight components -- */
        var streetLightBoxes = [];
        var streetLights = [];

        /* -- Variable to store windows -- */
        var windows = [];
        
        /* -- Constants that store information about the streetlight positions and scale, relative to blender -- */
        /* -- The z axis is simetrical in comparison to the blender coordinates (Threejs z = Blender -y)     -- */
        /* -- The offset is used to center the streetlight box into the right place                         -- */
        const scale = 3;
        const offset = 0.5;
        const streetLightHeight = 1.95;
        const streetLightPositions = [
            { x: 0, y: streetLightHeight, z: 1.05, rotation: 3*Math.PI/2 }, // Pointing downwards
            { x: 0, y: streetLightHeight, z: -1.05, rotation: Math.PI/2 }, // Pointing upwards
            { x: 1.05, y: streetLightHeight, z: 0, rotation: Math.PI }, // Pointing to the right
            { x: -1.05, y: streetLightHeight, z: 0, rotation: 0 }, // Pointing to the left
            // Down
            { x: -3, y: streetLightHeight, z: -4.95, rotation: 3*Math.PI/2 },
            { x: -1, y: streetLightHeight, z: -4.95, rotation: 3*Math.PI/2 },
            { x: 1, y: streetLightHeight, z: -4.95, rotation: 3*Math.PI/2 },
            { x: 3, y: streetLightHeight, z: -4.95, rotation: 3*Math.PI/2 },
            { x: 5, y: streetLightHeight, z: -4.95, rotation: 3*Math.PI/2 },
            { x: 7, y: streetLightHeight, z: -4.95, rotation: 3*Math.PI/2 },
            { x: -7, y: streetLightHeight, z: -1.95, rotation: 3*Math.PI/2 },
            // Up
            { x: 3, y: streetLightHeight, z: 4.95, rotation: Math.PI/2 },
            { x: 1, y: streetLightHeight, z: 4.95, rotation: Math.PI/2 },
            { x: -1, y: streetLightHeight, z: 4.95, rotation: Math.PI/2 },
            { x: -3, y: streetLightHeight, z: 4.95, rotation: Math.PI/2 },
            { x: -6, y: streetLightHeight, z: 4.95, rotation: Math.PI/2 },
            { x: -8, y: streetLightHeight, z: 4.95, rotation: Math.PI/2 },
            { x: -3, y: streetLightHeight, z: 7.95, rotation: Math.PI/2 },
            { x: -1, y: streetLightHeight, z: 7.95, rotation: Math.PI/2 },
            { x: 1, y: streetLightHeight, z: 7.95, rotation: Math.PI/2 },
            { x: 3, y: streetLightHeight, z: 7.95, rotation: Math.PI/2 },
            { x: -3, y: streetLightHeight, z: -1.05, rotation: Math.PI/2 },
            { x: 7, y: streetLightHeight, z: -1.05, rotation: Math.PI/2 },
            // Right
            { x: -8.95, y: streetLightHeight, z: 0, rotation: Math.PI },
            { x: -8.95, y: streetLightHeight, z: 3, rotation: Math.PI },
            { x: -4.95, y: streetLightHeight, z: -9, rotation: Math.PI },
            { x: -4.95, y: streetLightHeight, z: -6, rotation: Math.PI },
            { x: -4.95, y: streetLightHeight, z: -3, rotation: Math.PI },
            { x: -4.95, y: streetLightHeight, z: 0, rotation: Math.PI },
            { x: -4.95, y: streetLightHeight, z: 3, rotation: Math.PI },
            { x: -4.95, y: streetLightHeight, z: 6, rotation: Math.PI },
            { x: -4.95, y: streetLightHeight, z: 9, rotation: Math.PI },
            { x: 1.05, y: streetLightHeight, z: -3, rotation: Math.PI },
            { x: 1.05, y: streetLightHeight, z: 3, rotation: Math.PI },
            // Left
            { x: -4.05, y: streetLightHeight, z: 1.5, rotation: 0 },
            { x: 4.95, y: streetLightHeight, z: 0, rotation: 0 },
            { x: 4.95, y: streetLightHeight, z: 2, rotation: 0 },
            { x: 4.95, y: streetLightHeight, z: 4, rotation: 0 },
            { x: 4.95, y: streetLightHeight, z: 6, rotation: 0 },
            { x: 8.95, y: streetLightHeight, z: -3, rotation: 0 },
        ]

        const parkedCars = [
            /* -- 1st Row -- */
            { x: 5.25, y: 0.05, z: 4.8, rotation: Math.PI/2 },
            { x: 5.25, y: 0.05, z: 2.4, rotation: Math.PI/2 },
            { x: 5.25, y: 0.05, z: 6.4, rotation: 3*Math.PI/2 },
            /* -- 2nd Row -- */
            { x: 6.25, y: 0.05, z: 4.4, rotation: Math.PI/2 },
            { x: 6.25, y: 0.05, z: 6.4, rotation: 3*Math.PI/2 },
            /* -- 3nd Row --*/
            { x: 6.75, y: 0.05, z: 5.6, rotation: Math.PI/2 },
            { x: 6.75, y: 0.05, z: 5.2, rotation: 3*Math.PI/2 },
            { x: 6.75, y: 0.05, z: 3.2, rotation: 3*Math.PI/2 },
            /* -- 4th Row -- */
            { x: 7.75, y: 0.05, z: 4, rotation: Math.PI/2 },
        ]

        /* -- Apply the scale and offset to each streetlight position -- */
        for (var i in streetLightPositions) {
            streetLightPositions[i].x *= scale;
            streetLightPositions[i].z *= scale;

            if (streetLightPositions[i].rotation == 0) {
                streetLightPositions[i].x -= offset;
            } else if (streetLightPositions[i].rotation == Math.PI) {
                streetLightPositions[i].x += offset;
            } else if (streetLightPositions[i].rotation == Math.PI/2) {
                streetLightPositions[i].z -= offset;
            } else if (streetLightPositions[i].rotation == 3*Math.PI/2) {
                streetLightPositions[i].z += offset;
            }
        }

        /* -- Models -- */
        const models = [
            {
                name: "Map",
                path: "models/NightCity/NightCity.obj",
                mtl: "models/NightCity/NightCity.mtl",
            },
            {
                name: "Sedan",
                path: "models/Cars/sedan.obj",
                mtl: "models/Cars/sedan.mtl",
            },
        ]

        /* -- Function to create a streetlight -- */
        function createLight(params) {
            const lightGeometry = new THREE.BoxGeometry( 0.13, 0.05, 0.12 );
            const lightMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );
            const lightBox = new THREE.Mesh( lightGeometry, lightMaterial );

            lightBox.receiveShadow = true;
            lightBox.castShadow = true;
            lightBox.material.emissive.set( 0xffffff );
            lightBox.material.emissiveIntensity = 0.25;

            lightBox.position.set( params.x, params.y, params.z );
            lightBox.rotation.y = params.rotation;

            // Place a spotlight at the origin, pointing down the y-axis
            const spotLight = new THREE.SpotLight( 0xffffff, 1 );
            spotLight.position.set( params.x, params.y, params.z );
            spotLight.target.position.set( params.x, -1, params.z );
            spotLight.target.updateMatrixWorld();
            spotLight.visible = false;
            
            streetLights.push(spotLight);
            streetLightBoxes.push(lightBox);

            sceneElements.sceneGraph.add( lightBox );
            sceneElements.sceneGraph.add( spotLight );
            sceneElements.sceneGraph.add( spotLight.target );
        }

        /* -- Helper function, to facilitate setup and rendering -- */
        const helper = {

            initEmptyScene: function (sceneElements) {

                /* -- Setup the scene -- */
                sceneElements.sceneGraph = new THREE.Scene();

                /* -- Setup the perspective camera (default) -- */
                const width = window.innerWidth;
                const height = window.innerHeight;
                const aspectRatio = width / height;
                const perCamera = new THREE.PerspectiveCamera( 45, aspectRatio, 0.1, 2000 );
                cameras.perspective = perCamera;
                perCamera.position.set( 30, 18, 30 );
                perCamera.lookAt( 0, 5, 0 );

                sceneElements.camera = perCamera;

                /* -- Setup the orthographic camera -- */
                const ortCamera = new THREE.OrthographicCamera( width / -ortScale, width / ortScale, height / ortScale, height / -ortScale, 0.5, 1000 );
                cameras.orthographic = ortCamera;
                ortCamera.position.set( 30, 18, 30 );
                ortCamera.lookAt( 0, 5, 0 );

                /* -- Setup the first person camera -- */
                const fpsCamera = new THREE.PerspectiveCamera( 75, aspectRatio, 0.1, 1000 );
                fpsCamera.position.set( 2, 10, 0 );
                cameras.firstperson = fpsCamera;
                
                /* -- Ambient light -- */
                const ambientLight = new THREE.AmbientLight( 'rgb(214, 220, 227)', 0.05 );
                sceneElements.sceneGraph.add( ambientLight );

                /* -- Day-night cycle objects -- */
                daynight.sunSphere	= new THREEx.DayNight.SunSphere( );
                sceneElements.sceneGraph.add( daynight.sunSphere.object3d );

                daynight.sunLight	= new THREEx.DayNight.SunLight( );
                sceneElements.sceneGraph.add( daynight.sunLight.object3d );
                
                daynight.skydom	= new THREEx.DayNight.Skydom( );
                sceneElements.sceneGraph.add( daynight.skydom.object3d );


                /* -- Box placed at the bottom of the scene, to cover a black hole created by rendering issues -- */
                const geometry = new THREE.BoxGeometry(1500, 10, 1500);
                const mesh = new THREE.MeshStandardMaterial({ color: 0xCCCCCC });
                const foggedObject = new THREE.Mesh(geometry, mesh);
                foggedObject.position.set(0, -400, 0);
                sceneElements.sceneGraph.add(foggedObject);

                /* -- Create the streetlights -- */
                for (var i in streetLightPositions) {
                    createLight(streetLightPositions[i]);
                }
                console.log(streetLightBoxes.length);

                /* -- Setup the renderer -- */
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                sceneElements.renderer = renderer;
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( width, height );

                /* -- Shadow mapping -- */
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap; //THREE.BasicShadowMap | THREE.PCFShadowMap |  THREE.VSMShadowMap | THREE.PCFSoftShadowMap

                renderer.shadowMap.soft = true;
                renderer.shadowMap.bias = -0.0001;
                renderer.shadowMap.darkness = 1;
                renderer.shadowMap.width = 2048;
                renderer.shadowMap.height = 2048;


                /* -- Add the rendered image in the HTML DOM -- */
                const htmlElement = document.querySelector( "#Tag3DScene" );
                htmlElement.appendChild( renderer.domElement );


                /* -- Perspective camera controls (OrbitControls) (default) -- */
                controls.per = new OrbitControls( perCamera, renderer.domElement );
                controls.per.screenSpacePanning = true;
                controls.per.target.set(0, 5, 0);
                controls.per.maxDistance = 100;
                controls.per.saveState();
                
                controls.per.update();

                sceneElements.control = controls.per;

                /* -- Orthographic camera controls (OrbitControls) -- */
                controls.ort = new OrbitControls( ortCamera, renderer.domElement );
                controls.ort.screenSpacePanning = true;
                controls.ort.target.set( 0, 5, 0 );
                controls.ort.maxDistance = 100;
                controls.ort.saveState();

                controls.ort.update();

                /* -- First person camera controls (PointerLockControls) -- */
                controls.fps = new PointerLockControls( fpsCamera, renderer.domElement );
                controls.fps.disconnect();
                //controls.per.enabled = false; controls.ort.enabled = false;
                //controls.fps.connect(); controls.fps.lock(); controls.fps.isLocked === true;
                sceneElements.sceneGraph.add( controls.fps.getObject() );
            },

            render: function ( sceneElements ) {
                sceneElements.renderer.render( sceneElements.sceneGraph, sceneElements.camera );
            },
        };

        /* -- Scene loading functions -- */
        const scene = {

            load3DObjects: function ( sceneGraph ) {

                /* -- Create the grass ground -- */
                const loader = new THREE.TextureLoader();
                const grassTexture = loader.load('./images/grass/grass_texture.png');
                const displacementMap = loader.load('./images/grass/grass_displacement.png');
                const aoMap = loader.load('./images/grass/grass_ao.png');
                const roughnessMap = loader.load('./images/grass/grass_roughness.png');

                const factor = 8;

                grassTexture.wrapS = THREE.RepeatWrapping;
                grassTexture.wrapT = THREE.RepeatWrapping;
                grassTexture.repeat.set(factor, factor); // Adjust these values to scale the texture as needed

                displacementMap.wrapS = THREE.RepeatWrapping;
                displacementMap.wrapT = THREE.RepeatWrapping;
                displacementMap.repeat.set(factor, factor); // Adjust these values to match the grass texture

                aoMap.wrapS = THREE.RepeatWrapping;
                aoMap.wrapT = THREE.RepeatWrapping;
                aoMap.repeat.set(factor, factor); // Adjust these values to match the grass texture

                roughnessMap.wrapS = THREE.RepeatWrapping;
                roughnessMap.wrapT = THREE.RepeatWrapping;
                roughnessMap.repeat.set(factor, factor); // Adjust these values to match the grass texture

                const grassMaterial = new THREE.MeshStandardMaterial({
                    map: grassTexture,
                    displacementMap: displacementMap,
                    displacementScale: 0,
                    aoMap: aoMap,
                    aoMapIntensity: 0.5,
                    roughnessMap: roughnessMap,
                    roughness: 0.5,
                });

                const otherMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Brown color for the other sides

                const materials = [
                otherMaterial, // Right face
                otherMaterial, // Left face
                grassMaterial, // Top face 
                otherMaterial, // Bottom face
                otherMaterial, // Front face
                otherMaterial, // Back face
                ];

                const groundGeometry = new THREE.BoxGeometry( 60, 1000, 60 );
                const ground = new THREE.Mesh( groundGeometry, materials );
                ground.position.set( 0, -500, 0 );
                ground.receiveShadow = true;

                sceneGraph.add( ground );

                /* -- Setting up a loading manager -- */
                const manager = new THREE.LoadingManager();
                manager.onStart = function ( url, itemsLoaded, itemsTotal ) {
                    console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
                };

                manager.onLoad = function ( ) {
                    console.log( 'Loading complete!');
                };

                manager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
                    console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
                };

                manager.onError = function ( url ) {
                    console.log( 'There was an error loading ' + url );
                };

                /* -- Load the models -- */
                const mtlLoader = new MTLLoader( manager );

                const loadingPromises = [];

                models.forEach(model => {
                    const promise = new Promise((resolve, reject) => {
                        mtlLoader.load(
                            model.mtl,
                            (materials) => {
                                materials.preload()
                                const objLoader = new OBJLoader()
                                objLoader.setMaterials( materials )
                                objLoader.load(
                                    model.path,
                                    (object) => {
                                        console.log(object)
                                        object.traverse((child) => {
                                            if (child instanceof THREE.Mesh) {
                                                child.castShadow = true;
                                                child.receiveShadow = true;
                                            }
                                        });
                                        object.receiveShadow = true;
                                        object.castShadow = true;
                                        object.name = model.name;

                                        scene.setup( object );   
                                        sceneGraph.add( object );

                                        resolve();
                                    },
                                    (xhr) => {
                                        console.log( model.name + ' - ' + ( xhr.loaded / xhr.total ) * 100 + '% loaded' )
                                    },
                                    (error) => {
                                        console.log( model.name + ' - ' + 'An error happened' ); 
                                        reject(error);
                                    }
                                )
                            },
                            (xhr) => {
                                console.log( ( model.name + ' - ' + xhr.loaded / xhr.total ) * 100 + '% loaded' )
                            },
                            (error) => {
                                console.log( model.name + ' - ' + 'An error happened' )
                            }
                        )
                    });
                    loadingPromises.push(promise);
                });

                return Promise.all(loadingPromises);
            },

            setup: function ( obj ) {

                console.log( obj.name );
                
                if (obj.name == "Map") {
                    obj.scale.set( scale, scale, scale );
                    obj.position.set( 0, 0.01, 0 );

                    for (var i in obj.children) {
                        var child = obj.children[i];

                        if (child.name.startsWith('low') || child.name.startsWith('small') || child.name.startsWith('large') || child.name.startsWith('skyscraper')) {
                            for (var i in child.material) {
                                if (child.material[i].name.startsWith('window')) {
                                    child.material[i].emissive.set(0xffffff);
                                    child.material[i].emissiveIntensity = 0;
                                    windows.push(child.material[i]);
                                }
                            }
                        }
                    }
                }
                else if (obj.name == "Sedan") {
                    obj.scale.set( 0.5, 0.5, 0.5 );
                    obj.position.set( -14, 0.05, -29 );

                    let varCopy = obj.clone();
                    varCopy.name = "SedanCopy";
                    
                    for (var i in parkedCars) {
                        var parkedCar = varCopy.clone();
                        parkedCar.position.set( parkedCars[i].x * scale, parkedCars[i].y, parkedCars[i].z * scale );
                        parkedCar.rotation.y = parkedCars[i].rotation;
                        sceneElements.sceneGraph.add( parkedCar );
                    }
                }
            }
        };

        /* -- Animation variables and constants -- */

        let rcGround;
        let rcTop;
        let rcFront;
        let rcBack;
        let rcLeft;
        let rcRight;

        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let sprint = false;
        let canDoubleJump = false;
        let canJump = false;

        const normalSpeed = 40.0;
        const sprintSpeed = 70.0;
        const slowdownSpeed = 10.0;

        const gravity = 9.8;

        const charHeight = 0.6;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const vertex = new THREE.Vector3();
        const color = new THREE.Color();

        rcGround = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, charHeight );
        rcTop = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, 1, 0 ), 0, 0.1 );

        const sideRay = 0.2;
        rcFront = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, 0, 1 ), 0, sideRay );
        rcBack = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, 0, -1 ), 0, sideRay );
        rcLeft = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( -1, 0, 0 ), 0, sideRay );
        rcRight = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 1, 0, 0 ), 0, sideRay );

        var sunAngle = 1/6*Math.PI*2;
        var lightsOn = false;
        var dayDuration	= 60;

        let prevTime = performance.now();

        async function updateLights(turnOn) {
            for (var i in streetLights) {
                streetLights[i].visible = turnOn;
            }
            for (var i in streetLightBoxes) {
                streetLightBoxes[i].material.emissiveIntensity = turnOn ? 1 : 0.25;
            }

            for (var i in windows) {
               
                windows[i].emissiveIntensity = turnOn ? 0.6 : 0;
            }
        }

        function intersectObjects( raycaster ) {
            const intersects = [];
                var temp;
                for (var i in sceneElements.sceneGraph.children) {
                    if (sceneElements.sceneGraph.children[i] instanceof THREE.Group) {
                        temp = raycaster.intersectObjects(sceneElements.sceneGraph.children[i].children, true);
                        if (temp.length > 0) {
                            intersects.push(...temp);
                        }
                    } else if (sceneElements.sceneGraph.children[i] instanceof THREE.Mesh) {
                        temp = raycaster.intersectObject(sceneElements.sceneGraph.children[i]);
                        if (temp.length > 0) {
                            intersects.push(...temp);
                        }
                    }
                }
            
            return intersects;
        }


        function computeFrame() {
            /* -- FPS Controls adapted from https://threejs.org/examples/misc_controls_pointerlock.html -- */

            const time = performance.now();
            const delta = ( time - prevTime ) / 1000;

            var phase	= THREEx.DayNight.currentPhase(sunAngle)

            /* -- Streetlights -- */
            if ((phase === 'twilight' || phase === 'night') && !lightsOn) {
                /* -- Turning lights on -- */
                updateLights(true);
                lightsOn = true;
            } else if (phase === 'day' && lightsOn) {
                /* -- Turning lights off -- */
                updateLights(false);
                lightsOn = false;
            }

            /* -- Car movement -- */
            var car = sceneElements.sceneGraph.getObjectByName('Sedan');
            const carVelocity = 7;
            car.position.z += carVelocity * delta;

            if (car.position.z > 29) {
                car.position.z = -30;
            }
            
            /* -- FPS Controls -- */
            if ( controls.fps.isLocked === true && sceneElements.camera == cameras.firstperson ) {
                rcGround.ray.origin.copy( controls.fps.getObject().position );
                
                /* -- Ground collision -- */
                let groundIntersects = intersectObjects( rcGround );

                /* -- Step up -- */
                if ( groundIntersects.length > 0 ) {

                    var distance = groundIntersects[0].distance;
                    if ( distance == undefined ) {
                        distance = 1000;
                        console.log(groundIntersects[0])
                    }
                    
                    for ( let i = 1; i < groundIntersects.length; i ++ ) {
                        if ( groundIntersects[i].distance < distance && groundIntersects[i].distance != undefined) {
                            distance = groundIntersects[i].distance;
                        }
                    }

                    if ( distance > charHeight/2 && distance < charHeight ) {
                        controls.fps.getObject().position.y += (charHeight - distance);
                    }
                }

                /* -- Top collision -- */
                rcTop.ray.origin.copy( controls.fps.getObject().position );

                let topIntersects = intersectObjects( rcTop );

                if ( topIntersects.length > 0 ) {
                    velocity.y = 0;
                }

                const onObject = groundIntersects.length > 0;

                velocity.x -= velocity.x * slowdownSpeed * delta;
                velocity.z -= velocity.z * slowdownSpeed * delta;

                velocity.y -= gravity * 3.0 * delta; // 100.0 = mass

                direction.z = Number( moveForward ) - Number( moveBackward );
                direction.x = Number( moveRight ) - Number( moveLeft );
                direction.normalize(); // this ensures consistent movements in all directions

                if ( moveForward || moveBackward ) velocity.z -= direction.z * (sprint ? sprintSpeed : normalSpeed) * delta;
                if ( moveLeft || moveRight ) velocity.x -= direction.x * (sprint ? sprintSpeed : normalSpeed) * delta;

                /* -- Front collision -- */
                rcFront.ray.origin.copy( controls.fps.getObject().position );
                rcFront.ray.origin.y -= 1*charHeight/4;

                let frontIntersects = intersectObjects( rcFront );

                if ( frontIntersects.length > 0 ) {
                    velocity.z = 0;
                    controls.fps.getObject().position.z += frontIntersects[0].distance - sideRay;
                }

                /* -- Back collision -- */
                rcBack.ray.origin.copy( controls.fps.getObject().position );
                rcBack.ray.origin.y -= 1*charHeight/4;

                let backIntersects = intersectObjects( rcBack );

                if ( backIntersects.length > 0 ) {
                    velocity.z = 0;
                    controls.fps.getObject().position.z -= backIntersects[0].distance - sideRay;
                }

                /* -- Left collision -- */
                rcLeft.ray.origin.copy( controls.fps.getObject().position );
                rcLeft.ray.origin.y -= 1*charHeight/4;

                let leftIntersects = intersectObjects( rcLeft );

                if ( leftIntersects.length > 0 ) {
                    velocity.x = 0;
                    controls.fps.getObject().position.x -= leftIntersects[0].distance - sideRay;
                }

                /* -- Right collision -- */
                rcRight.ray.origin.copy( controls.fps.getObject().position );
                rcRight.ray.origin.y -= 1*charHeight/4;

                let rightIntersects = intersectObjects( rcRight );

                if ( rightIntersects.length > 0 ) {
                    velocity.x = 0;
                    controls.fps.getObject().position.x += rightIntersects[0].distance - sideRay;
                }

                /* -- Jump logic -- */
                if ( onObject === true ) {

                    velocity.y = Math.max( 0, velocity.y );
                    canJump = true;

                }

                controls.fps.moveRight( - velocity.x * delta );
                controls.fps.moveForward( - velocity.z * delta );

                controls.fps.getObject().position.y += ( velocity.y * delta ); // new behavior

                if ( controls.fps.getObject().position.y < 0.55 ) {

                    velocity.y = 0;
                    controls.fps.getObject().position.y = 0.55;

                    canJump = true;

                }

                if (Math.abs(controls.fps.getObject().position.x) > 30) {
                    
                    velocity.x = 0;
                    controls.fps.getObject().position.x = controls.fps.getObject().position.x > 0 ? 30 : -30;

                }

                if (Math.abs(controls.fps.getObject().position.z) > 30) {
                    
                    velocity.z = 0;
                    controls.fps.getObject().position.z = controls.fps.getObject().position.z > 0 ? 30 : -30;

                }
            }
            
            /* -- Day-night cycle -- */
            sunAngle += delta/dayDuration * Math.PI*2;
            daynight.skydom.update(sunAngle);
            daynight.sunLight.update(sunAngle);
            daynight.sunSphere.update(sunAngle);

            prevTime = time;

            /* -- Render the scene -- */
            helper.render( sceneElements );

            /* -- Request the next frame -- */
            requestAnimationFrame( computeFrame );
        }

        /* -- Initialization function -- */
        function init() {
            helper.initEmptyScene( sceneElements );
            scene.load3DObjects( sceneElements.sceneGraph ).then(() => {
                requestAnimationFrame( computeFrame );
            });
        }

        /* -- Event listeners -- */

        /* -- Resize the window -- */
        function resizeWindow( eventParam ) {
            const width = window.innerWidth;
            const height = window.innerHeight;

            if (sceneElements.camera.isPerspectiveCamera) {
                sceneElements.camera.aspect = width / height;
                sceneElements.camera.updateProjectionMatrix();            
            }
            else {
                cameras.orthographic.left = width / -ortScale;
                cameras.orthographic.right = width / ortScale;
                cameras.orthographic.top = height / ortScale;
                cameras.orthographic.bottom = height / -ortScale;
            }

            sceneElements.renderer.setSize( width, height );

            helper.render( sceneElements );
        }

        /* -- Keyboard events -- */
        const onKeyDown = function ( event ) {

            switch ( event.code ) {

                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;

                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;

                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;

                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;

                case 'ShiftLeft':
                    sprint = true;
                    break;

                case 'Space':
                    if ( canJump === true ) {
                        velocity.y = 10;
                        canDoubleJump = true;
                    }
                    else if ( canDoubleJump === true ) {
                        velocity.y = 10;
                        canDoubleJump = false;
                    }
                    canJump = false;
                    break;

                case 'KeyR':
                    controls.per.reset();
                    controls.ort.reset();
                    controls.fps.reset();
                    break;
                
                case 'KeyP':
                    if (sceneElements.camera == cameras.perspective) {
                        console.log( "Orthographic Camera" );

                        sceneElements.camera = cameras.orthographic;
                    }
                    else if (sceneElements.camera == cameras.orthographic) {
                        console.log( "First Person Camera" );

                        sceneElements.camera = cameras.firstperson;
                        controls.fps.connect(); controls.fps.lock();
                        controls.per.enabled = false; controls.ort.enabled = false;
                    }
                    else {
                        console.log( "Perspective Camera" );

                        controls.fps.disconnect(); controls.fps.unlock(); controls.fps.isLocked = false;
                        controls.per.enabled = true; controls.ort.enabled = true;
                        sceneElements.camera = cameras.perspective;
                    }

                    controls.ort.update();
                    controls.per.update();

                    break;

            }

        };

        const onKeyUp = function ( event ) {

            switch ( event.code ) {

                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;

                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;

                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;

                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;

                case 'ShiftLeft':
                    sprint = false;
                    break;

            }

        };

        window.addEventListener( 'resize', resizeWindow );
        document.addEventListener( 'keydown', onKeyDown );
        document.addEventListener( 'keyup', onKeyUp );

        /* -- Start the application -- */
        init();

    </script>

</head>

<body>
    <div id="Tag3DScene"> </div>
</body>

</html>